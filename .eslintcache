[{"C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\index.js":"1","C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\components\\HandCalculator.js":"2","C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\components\\PokerView.js":"3","C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\App.js":"4","C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\reportWebVitals.js":"5"},{"size":500,"mtime":1609449455432,"results":"6","hashOfConfig":"7"},{"size":14725,"mtime":1612717488774,"results":"8","hashOfConfig":"7"},{"size":9019,"mtime":1612718333443,"results":"9","hashOfConfig":"7"},{"size":226,"mtime":1612048233497,"results":"10","hashOfConfig":"7"},{"size":362,"mtime":1609449455432,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"pakxsj",{"filePath":"15","messages":"16","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\index.js",[],["27","28"],"C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\components\\HandCalculator.js",["29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48"],"/*\r\n * ()=>{\r\n\t\t\t\t\t\tfakeArray = array.filter((num)=>{return num != array[i]%13});\r\n\t\t\t\t\t\t\tlet secondPair = pairFinder(fakeArray);\r\n\t\t\t\t\t\t\tif(secondPair <2000) return false;\r\n\t\t\t\t\t\t\telse if(secondPair >= 2000 && secondPair <3000){\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\treturn 5000 + array[i]%13 + secondPair - 2000;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(secondPair >array[i]%13+3000) return secondPair + array[i]%13 + 5000;\r\n\t\t\t\t\t\t\telse if(secondPair > 4000) return secondPair;\r\n\t\t\t\t\t\t\t}\r\n * \r\n * \r\n * \r\n * \r\n * \r\n * */\r\n\r\n\r\n\r\n\r\n\r\n\r\n//takes seven card input and returns hand strength\r\n//a stronger hand should always return a greater hand strength than a weaker hand\r\n\r\n//input format:\r\n\r\nexport {thirteen, handEvaluator};\r\n\r\nfunction flushFinder (input) {\r\n\tlet ray = input.slice();\r\n\tconsole.log(ray);\r\n\tlet clubsHeartsSpadesDiamonds = [[],[],[],[]];\r\n\tlet count = [0,0,0,0,];\r\n\tfor(let i = 0; i<ray.length;i++){\r\n\t\t\r\n\t\tif(ray[i]<=13){\r\n\t\t\t\r\n\t\t\tclubsHeartsSpadesDiamonds[0].push(ray[i]);\r\n\t\t\tcount[0]++;\r\n\t\t}\r\n\t\telse if (ray[i]>13&&ray[i]<=26){\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tclubsHeartsSpadesDiamonds[1].push(ray[i]);\r\n\t\t\tcount[1]++;\r\n\t\t}\r\n\t\telse if (ray[i]>26&&ray[i]<=39){\r\n\t\t\t\t\r\n\t\t\tclubsHeartsSpadesDiamonds[2].push(ray[i]);\r\n\t\t\tcount[2]++;\r\n\t\r\n\t\t}\r\n\t\telse if (ray[i]>39&&ray[i]<=52){\r\n\t\t\t\r\n\t\t\tclubsHeartsSpadesDiamonds[3].push(ray[i]);\r\n\t\t\tcount[3]++;\r\n\t\t\t\r\n\t\t}\r\n\t\telse console.log(\"couldn't catch  \" + ray[i]);\r\n\t}\r\n\t\r\n\tlet payout = count.indexOf(Math.max(...count));\r\n\t//console.log(count[0]);\r\n\t//console.log(Math.max(...count));\r\n\t//console.log(\"payout array:\" + clubsHeartsSpadesDiamonds[payout]);\r\n\tif(count[payout]>=5) { //there's a flush\r\n\t\r\n\t\t\tlet straightFlush = straightFinder(clubsHeartsSpadesDiamonds[payout]);//remember these are raw inputs\r\n\t\t\tif(straightFlush){\r\n\t\t\t\t\r\n\t\t\t\treturn straightFlush * 2; //should be +7000 since straight = 3500\r\n\t\t\t\t//aces are still low in a straight flush, so regular straightFinder should work\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\r\n\t\t\t\twhile(clubsHeartsSpadesDiamonds[payout].length>5){\r\n\t\t\t\t\t\r\n\t\t\t\t\tclubsHeartsSpadesDiamonds[payout].splice(clubsHeartsSpadesDiamonds[payout].indexOf(Math.min(clubsHeartsSpadesDiamonds[payout])), 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn 4000 + (()=>{\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet payload = 0;\r\n\t\t\t\t\tfor(let i in clubsHeartsSpadesDiamonds[payout]){\r\n\t\t\t\t\t\tpayload += kickerCalculator(clubsHeartsSpadesDiamonds[payout][i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn payload;\r\n\t\t\t\t\t\r\n\t\t\t\t\t})()\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\r\n\t}\r\n\telse return false;\r\n}\r\nfunction straightFinder(ray) {\r\n\r\n\tlet array = [...ray].map(val=>thirteen(val)).sort((a,b)=>a-b);\r\n\tlet containsZero = false;\r\n\tfor(let i in array){\r\n\t\tif(array[i] === 13) {\r\n\t\t\tcontainsZero = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t} \r\n\tif(containsZero) array.unshift(0);\r\n\tconsole.log(array);\r\n\tlet straight = [array[0]];\r\n\r\n\tfor(let i in array){\r\n\r\n\t\t//if it is not a duplicate\r\n\t\tif(array[i]!==straight[straight.length-1]) {\r\n\t\t\t//if it comes after the last\r\n\t\t\tif(array[i]===straight[straight.length-1]+1){\r\n\t\t\t\tstraight[straight.length] = array[i];\r\n\t\t\t}\r\n\t\t\telse if(array.length-i+1<5) break; //not enough remain\r\n\t\t\telse if(straight.length<5) straight = [array[i]];//reset the straight\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconsole.log(straight);\r\n\r\n\treturn (straight.length>=5) ? 3500 + highCard(straight) : false;\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n//returns the highest possible straight from given array\r\nfunction oldStraightFinder(ray) {\r\n\t\r\n\tlet array = [...ray];\r\n\t//populate array with normalized input\r\n\tfor(let i = 0; i<array.length; i++){\r\n\r\n\t\t\r\n\t\tarray[i] = thirteen(array[i]);\r\n\r\n\t\tif(array[i]==13){array[array.length] = 0;}//ace is both low and high\r\n\t\t\r\n\t\t\r\n\t}\r\n//console.log(\"debug: array =\" + array);\r\n\t\r\n\tlet highestToLowest = [];\r\n//console.log(\"debug: mathmax array = \" + array.splice(array.indexOf(Math.max(...array)),1));\r\n\t\r\n\thighestToLowest.push(array.splice(array.indexOf(Math.max(...array)),1));\r\n//console.log(highestToLowest[0]);\r\n\twhile(array.length>0&&highestToLowest.length<5){\r\n\t\t\r\n\t\thighestToLowest.push(array.splice(array.indexOf(Math.max(...array)),1));\r\n\r\n\t\t//console.log(highestToLowest[1]);\r\n\t\t\r\n\t\t\r\n\t\tif(highestToLowest[highestToLowest.length-1] != (highestToLowest[highestToLowest.length - 2] -1)){\r\n//console.log(\"debug true\" + Number(highestToLowest[highestToLowest.length-1] + 1 ) + \"\" + highestToLowest[highestToLowest.length - 2]);\r\n\t\t\t\r\n\t\t\tif(highestToLowest[highestToLowest.length-1] == highestToLowest[highestToLowest.length - 2]){ //it's because of a repeat\r\n\t\t\t\t\r\n\t\t\t\thighestToLowest.pop();//deletes repeats instead of resetting array\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse { \r\n\t\t\t\t\r\n\r\n\r\n\t\t\t\t\thighestToLowest = [highestToLowest[highestToLowest.length-1]];//reset array\r\n\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t}\r\n//console.log(\"debug: highestToLowest = \" + highestToLowest);\r\n\tif(highestToLowest.length==5){\r\n//console.log(\"true\");\r\n\t\t\r\n\t\t//return highestToLowest.reduce(((total,value)=>{total += kickerCalculator(value)}),0) + 3500; //gives nan for some reason\r\n\t\tlet weightedPayload = 0;\r\n\tfor (let i = 0; i<highestToLowest.length; i++){\r\n\t\tweightedPayload += kickerCalculator(highestToLowest[i]);\r\n}\r\n\treturn weightedPayload + 3500;\r\n\r\n\t}\r\n\telse return false;\r\n\t\t\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\r\n\t\r\n\t\r\n\t\r\n}\r\n//1. check for royal flush\r\n//2. check for flush\r\n//3. check for straight\r\n// returns Ms + top card % 13\r\n\r\n//4. check for pair/trip/quads\r\n\r\n//returns Mp,Mt,Mq + top 3, 2, 1\r\n\r\n//pairfinder\r\n\r\nfunction newPairFinder (ray) {\r\n\r\n\tlet array = ray.map(val => thirteen(val)).sort().reverse();\r\n\tlet count = 0;\r\n\tlet max = 0;\r\n\tfor(let i = 0; i<array.length; i++){\r\n\r\n\t\tif(i<array.length) {\r\n\r\n\t\t\tif(array[i]===array[i+1]){\r\n\t\t\t\tcount++;\r\n\t\t\t\tmax = array[i];\r\n\t\t\t} else if (count>0) {\r\n\t\t\t\ti = array.length;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tconsole.log(count);\r\n\r\n\r\n\tswitch(count) {\r\n\r\n\t\tcase 1: \r\n\t\t\treturn max + 2000;\r\n\t\tcase 2: \r\n\t\t\treturn max + 3000;\r\n\t\tcase 3: \r\n\t\t\treturn max + 6000;\r\n\t\tdefault:\r\n\t\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconsole.log(array + \"is false??\");\r\n\r\n\treturn false;\r\n\r\n\r\n\t\r\n/*\r\n\tfor(let i = array.length-1; i>0; i--){\r\n\t\tif(array[i]===array[i-1]){\r\n\t\t\tcount++;\r\n\r\n\t\t} else if(count>0){\r\n\r\n\t\t\tswitch(count) {\r\n\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\treturn array[i]+2000;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\treturn array[i]+3000;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\treturn array[i]+6000;\r\n\t\t\t\tdefault: return false;\r\n\t\t\t}\r\n\r\n\t\t} else console.log(array[i] + \" != \" + array[i-1])\r\n\t\t\r\n\t}*/\r\n\r\n\t\r\n\t//pairevaluator is expecting an unordered list of pairs\r\n\t//we can just greedily return the first found pair\r\n\r\n\r\n}\r\n/*\r\nfunction pairFinder (ray) {\r\n\t\r\n\tlet array = [...ray]; //we mutate this\r\n\t\r\n\tfor (let i = 0; i<array.length;i++){\r\n\t\t\r\n\t\tfor(let j = i +1; j<array.length; j++){\r\n\t\t\t\r\n\t\t\tif(thirteen(array[i]) == thirteen(array[j])){\r\n\t\t\t\t\r\n\t\t\t\treturn ((()=>{\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(j; j<array.length; j++){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(thirteen(array[i])==thirteen(array[j])){\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\treturn ((()=>{for(j;j<array.length;j++){if(thirteen(array[i])==thirteen(array[j])){\r\n\t\t\t\t\t\t\t\t//only higher quads beat\r\n\t\t\t\t\t\t\t\treturn thirteen(array[i]) + 6000 //kickerCalculator(Math.max(array.filter((num)=>{thirteen(num)!=thirteen(array[i])})));//quads\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} return false;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t})() || thirteen(array[i]) + 3000) //trips\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;//no trips\r\n\t\t\t\t\t\r\n\t\t\t\t\t})() || thirteen(array[i]) + 2000)//will either return the number of the pair or false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}*/\r\n\r\n//second step is to filter the remaining cards, then run pairFinder on them again, until no cards remain or it returns less than a pair.\r\n\r\nfunction pairEvaluator (ray) {\r\n\t\r\n\tlet scores = [];\r\n\tlet array = [...ray];\r\n\t\r\n\t\r\n\tscores[0] = newPairFinder(array) || 0;\r\n\t\r\n\tif(scores[0]>0){ //pairfinder returned a pair\r\n\t\t\t//console.log(array);\r\n\t\tarray = array.filter(num=>thirteen(num)!=scores[0]%1000);\r\n\t\t\t//console.log(array);\r\n\t\t\tscores[1] = newPairFinder(array) || 0;\r\n\r\n\t\t\tif(scores[1]>0){\r\n\t\t\t\t\tarray = array.filter(num=>thirteen(num)!=scores[1]%1000);\r\n\t\t\t\t\tscores[2] = newPairFinder(array) || 0;\r\n\t\t\t}//there's only 3 possible pairs in any set of 7 cards, 2 = 3\r\n\t}\r\n\telse return false;\r\n\t\r\n\tlet max = Math.max(...scores);\r\n\t\r\n\tif(max>6000) {\r\n\t\tconsole.log(\"over 6k\");\r\n\t\treturn max - max%1000 + kickerCalculator((max%1000)+13) + kickerCalculator(Math.max(...ray.filter(val=>thirteen(val!=thirteen(max%1000))).map(val=>thirteen(val))));//probably quads\r\n\t\t//return max - max%1000 + kickerCalculator((max%1000)+13) + kickerCalculator(Math.max(array.filter((num)=>{return thirteen(num)!=thirteen(max%6000)})));\r\n\t}\r\n\telse if(max>3000){\r\n\t\t\r\n\t\tconsole.log(scores);\r\n\t\tscores = scores.filter(num=>num!=max);\r\n\t\treturn ((Math.max(...scores)>0) ? \r\n\t\t\t\r\n\t\t\tmax - max%1000 + kickerCalculator((max%1000)+13) * 3 \r\n\t\t\t+ Math.max(...scores) - Math.max(...scores)%1000 + kickerCalculator((Math.max(...scores)%1000)+13) * 2\r\n\t\t\t+ ((Math.max(...scores)>=3000) ? -1000 : 0)\r\n\t\t\t: max - max%1000 + kickerCalculator((max%1000)+13)+ (()=>{\r\n\t\t\t\tarray = [...ray].filter((num)=>{return thirteen(num)!=max%1000}).map(val=>thirteen(val));\r\n\t\t\t\tlet bigTwo = 0;\r\n\t\t\t\tfor(let i = 0; i<2; i++){\r\n\t\t\t\t\tbigTwo += kickerCalculator(Math.max(...array));\r\n\t\t\t\t\tarray = array.filter(val=>val!=Math.max(...array));\r\n\t\t\t\t}\r\n\t\t\t\treturn bigTwo;\r\n\t\t\t})())//creates a + 5000 hand with highest pair or adds the top 2 kickers\r\n\t\t\r\n\t}\r\n\telse if(max>2000){\r\n\t\tscores = scores.filter((num)=>{return num!=max});\t\r\n\t\tlet secondPair = Math.max(...scores) | 0;\r\n\t\treturn ((secondPair>0) ? \r\n\r\n\r\n\t\t\tmax - max%1000 + secondPair - secondPair%1000 - 1500 +\r\n\t\t\t(kickerCalculator(max%1000)) * 49*28 +\r\n\t\t\t(kickerCalculator(secondPair%1000)) *49*21 +\r\n\t\t\t\r\n\t\t\tkickerCalculator(\r\n\t\t\t\tMath.max(\r\n\t\t\t\t\t...[...ray].map(val=>thirteen(val)).filter(val=>val!=max%1000&&val!=secondPair%1000)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\r\n\r\n\t\t/*\r\n\t\tmax - max%1000 + kickerCalculator((max%1000)+13) * 2 + kickerCalculator((Math.max(...scores)%1000)+13) * 2  + Math.max(...scores) - 1500 - Math.max(...scores)%1000\r\n\t\t+ kickerCalculator(Math.max(\r\n\t\t\t...ray.map(val=>thirteen(val)).filter(val=>val!=max%1000 && val!=Math.max(...scores)%1000)\r\n\t\t\t\r\n\t\t\t//.filter(val=>val!=max%1000 && val!=Math.max(...scores)%1000)\r\n\t\t))*/\r\n\t\t: max - max%1000 + max%1000*7 +  highCard([max%1000, max%1000, ...resizer([...ray].map(val=>thirteen(val)).filter(val=>val!=max%1000), 3)])//fix this now\r\n\t\t\t\r\n\t\t\r\n\t\t)//2p evaluates to 2500 + remainder or + 3 kickers\r\n\t\r\n\t}\r\n\t\r\n\telse {\r\n\t\tconsole.log(\"error no pair but still got here\");\r\n\t\treturn false}\r\n\t\r\n\t\r\n}\r\n//needs a raw kicker\r\nfunction kickerCalculator (kicker) {\r\n//for math reasons, powers of 7 are enough to ensure top kicker wins over summed lower cards\r\n\treturn ((thirteen(kicker))*Math.pow(7,thirteen(kicker)/3))/3000000;\r\n\t\r\n\t\r\n\t\r\n\t}\r\n\t//fixes 13%13 = 0 problem\r\nfunction thirteen (number) {\r\n\tif (number == 0) return 0;\r\n\r\n\tif (number % 13 == 0 ) return 13;\r\n\telse return number%13;\r\n\t\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n//5. return sum of top 5 cards\r\n\r\n//this simple method loops twice to remove two lowest cards and returns the sum of the remaining card values\r\n\r\n\r\nfunction highCard (input){\r\n\r\n\t//posible future change: \r\n\t// * add new default param, len = 5\r\n\t\r\n\t\r\n\r\n{\r\n/*\r\nfor(let i = array.length-1; i>0; i--){\r\n\r\n\r\nif(array[i]<array[i-1]){\r\n\r\n[array[i]][array[i-1]] = [array[i-1]][array[i]];\r\n}\r\n\r\n}\r\n\r\narray.shift(); //removes the lowest*/\r\n/*\r\nwhile(array.length>5){\r\n\tlet minIndex = array.indexOf(Math.min(...array));\r\n\t\r\n\tif(array[0]!=array[minIndex]){\r\n\t\t//swap\r\n\t\t[array[0]][array[minIndex]] = [array[minIndex]][array[0]];\r\n\t}\r\n\telse array.shift();\r\n\t\r\n\t\r\n}*/ \r\n\r\n}\r\n\tlet array = [...input].map(val=>thirteen(val)).sort((a,b)=>a-b);\r\n\twhile(array.length>5){\r\n\t\tarray.shift();\r\n\t}\r\n\r\n\treturn array.reduce((acc, val)=>acc+kickerCalculator(val));\r\n}\r\n\r\n\r\n//scope for j\r\n\t/*{let j = 0;\r\n\t\tlet summer = (array) => {\r\n\r\n\t\t\tfor(let i = 0; i<array.length;i++){\r\n\t\t\t\r\n\t\t\t\tj += kickerCalculator(array[i]); \r\n\t\t\t}\r\n\t\t\treturn j;\r\n\t\t}\r\n\t\t\treturn summer(array);\r\n\r\n\t\t}\r\n\t}*/\r\n\r\n//all the work we did above lets us easily compare by hand value\r\n//every function always returns the highest possible hand by that method\r\nfunction handEvaluator (array){\r\n\t\r\n\tlet hand = [];\r\n\thand[hand.length] = flushFinder(array)||0;\r\n\thand[hand.length] = straightFinder(array)||0;\r\n\thand[hand.length] = pairEvaluator(array)||0;\r\n\thand[hand.length] = highCard(array)||0;\r\n\t//console.log(array);\r\n\t//console.log(Math.max(...hand));\r\n\treturn Math.max(...hand);\r\n\t\r\n\t\r\n}\r\n\r\nfunction resizer (array, newLength) {\r\n\tlet output = [...array].sort((a,b)=>a-b);\r\n\r\n\twhile(output.length>newLength){\r\n\t\toutput.shift();\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/*\r\nfunction fiveLowest (array) {\r\n\tlet temp = [...array];\r\n\twhile(temp.length>5){\r\n\t\ttemp.shift();\r\n\t}\r\n\treturn temp;\r\n}*/\r\n\r\n//console.log(\"Kicker finds: \" + kickerCalculator(6));\r\nconst thisarray = [17,22,43,35,23,30,34];//console.log(\"Highcard = \" + highCard(thisarray));\r\n//second hand\r\nconsole.log(\"handevaluator: \" + handEvaluator(thisarray));\r\n//console.log(straightFinder(thisarray));\r\n//console.log(newStraightFinder(thisarray));\r\n//console.log(\"highCard \" + highCard(thisarray));\r\nconsole.log(\"handevaluator: \" + handEvaluator([1,24,43,35,23,30,34])); //no longer throwing errors\r\n//console.log(straightFinder([9,42,35,11,3,33,21]));\r\nconsole.log(\"pairevaluator: \" + pairEvaluator(thisarray));\r\n//console.log(\"pairevaluator: \" + pairEvaluator([45,37,42,7,12,51,3]));\r\n//console.log(\"highCard \" + highCard([21,45,36,38,29,18,26]));\t\r\n\r\nconsole.log(\"winner is \" + (handEvaluator(thisarray)>handEvaluator([1,24,43,35,23,30,34])));\r\n\r\n//console.log(kickerCalculator(7));\r\n//console.log(kickerCalculator(37));\r\n//console.log((kickerCalculator(13)+kickerCalculator(5))-(kickerCalculator(13)+kickerCalculator(3)));\r\n//console.log(\"raw kickers yield: \")\r\n//console.log(thisarray.map(val=>thirteen(val)).sort());\r\n//console.log(fiveLowest(thisarray.map(val=>thirteen(val)).sort()).reduce((acc,val)=>acc+kickerCalculator(val)));\r\n//console.log(fiveLowest(thisarray.map(val=>thirteen(val)).sort()).map(val=>`${val} : ${kickerCalculator(val)}`));\r\n//console.log([37,3,23,48,46,52,13].map(val=>thirteen(val)).sort());\r\n//console.log(fiveLowest([37,3,23,48,46,52,13].map(val=>thirteen(val)).sort()).reduce((acc,val)=>acc+kickerCalculator(val)));\r\n//console.log(fiveLowest([37,3,23,48,46,52,13].map(val=>thirteen(val)).sort()).map(val=>`${val} : ${kickerCalculator(val)}`));\r\n//console.log(kickerCalculator(thisarray)); //this needs a single int input...\r\n\r\n//console.log(pairFinder(thisarray));\r\n//console.log(pairEvaluator(thisarray));\r\n//console.log(\"newpairfainder\" + newPairFinder(thisarray));\r\n//console.log(\"newpairfainder\" + newPairFinder([40,27,35,1]));\r\n//console.log([40,27,35,1].map(a=>thirteen(a)));\r\n//console.log(\"newpairfainder\" + newPairFinder([40,27,35,1].map(a=>thirteen(a))));\r\n//console.log(flushFinder(thisarray));//basically works\r\n//console.log(straightFinder(thisarray)); //fixed\r\n\r\n","C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\components\\PokerView.js",["49","50"],"C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\App.js",["51"],"import logo from './logo.svg';\nimport './App.css';\nimport PokerView from './components/PokerView';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nfunction App() {\n  return (\n    \n    <PokerView />\n\n  );\n}\n\nexport default App;\n",["52","53"],"C:\\Users\\Owner\\Desktop\\poker calculator\\poker-calculator\\src\\reportWebVitals.js",[],["54","55"],{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","replacedBy":"59"},{"ruleId":"60","severity":1,"message":"61","line":140,"column":10,"nodeType":"62","messageId":"63","endLine":140,"endColumn":27},{"ruleId":"64","severity":1,"message":"65","line":149,"column":14,"nodeType":"66","messageId":"67","endLine":149,"endColumn":16},{"ruleId":"64","severity":1,"message":"68","line":167,"column":48,"nodeType":"66","messageId":"67","endLine":167,"endColumn":50},{"ruleId":"64","severity":1,"message":"65","line":170,"column":49,"nodeType":"66","messageId":"67","endLine":170,"endColumn":51},{"ruleId":"64","severity":1,"message":"65","line":187,"column":27,"nodeType":"66","messageId":"67","endLine":187,"endColumn":29},{"ruleId":"69","severity":1,"message":"70","line":257,"column":2,"nodeType":"71","messageId":"72","endLine":259,"endColumn":15},{"ruleId":"64","severity":1,"message":"68","line":339,"column":42,"nodeType":"66","messageId":"67","endLine":339,"endColumn":44},{"ruleId":"64","severity":1,"message":"68","line":344,"column":45,"nodeType":"66","messageId":"67","endLine":344,"endColumn":47},{"ruleId":"64","severity":1,"message":"68","line":354,"column":118,"nodeType":"66","messageId":"67","endLine":354,"endColumn":120},{"ruleId":"64","severity":1,"message":"68","line":360,"column":34,"nodeType":"66","messageId":"67","endLine":360,"endColumn":36},{"ruleId":"64","severity":1,"message":"68","line":367,"column":57,"nodeType":"66","messageId":"67","endLine":367,"endColumn":59},{"ruleId":"73","severity":1,"message":"74","line":371,"column":27,"nodeType":"75","messageId":"76","endLine":371,"endColumn":55},{"ruleId":"64","severity":1,"message":"68","line":371,"column":35,"nodeType":"66","messageId":"67","endLine":371,"endColumn":37},{"ruleId":"64","severity":1,"message":"68","line":378,"column":44,"nodeType":"66","messageId":"67","endLine":378,"endColumn":46},{"ruleId":"64","severity":1,"message":"68","line":389,"column":57,"nodeType":"66","messageId":"67","endLine":389,"endColumn":59},{"ruleId":"64","severity":1,"message":"68","line":389,"column":72,"nodeType":"66","messageId":"67","endLine":389,"endColumn":74},{"ruleId":"64","severity":1,"message":"68","line":401,"column":125,"nodeType":"66","messageId":"67","endLine":401,"endColumn":127},{"ruleId":"64","severity":1,"message":"65","line":424,"column":13,"nodeType":"66","messageId":"67","endLine":424,"endColumn":15},{"ruleId":"64","severity":1,"message":"65","line":426,"column":18,"nodeType":"66","messageId":"67","endLine":426,"endColumn":20},{"ruleId":"77","severity":1,"message":"78","line":447,"column":1,"nodeType":"79","messageId":"80","endLine":473,"endColumn":2},{"ruleId":"60","severity":1,"message":"81","line":3,"column":9,"nodeType":"62","messageId":"63","endLine":3,"endColumn":28},{"ruleId":"60","severity":1,"message":"82","line":3,"column":53,"nodeType":"62","messageId":"63","endLine":3,"endColumn":59},{"ruleId":"60","severity":1,"message":"83","line":1,"column":8,"nodeType":"62","messageId":"63","endLine":1,"endColumn":12},{"ruleId":"56","replacedBy":"84"},{"ruleId":"58","replacedBy":"85"},{"ruleId":"56","replacedBy":"86"},{"ruleId":"58","replacedBy":"87"},"no-native-reassign",["88"],"no-negated-in-lhs",["89"],"no-unused-vars","'oldStraightFinder' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'array'.","ArrowFunctionExpression","unsafeRefs","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","'UncontrolledTooltip' is defined but never used.","'Figure' is defined but never used.","'logo' is defined but never used.",["88"],["89"],["88"],["89"],"no-global-assign","no-unsafe-negation"]